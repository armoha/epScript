%include {

#include <stdio.h>
#include <assert.h>
#include <string>
#include <iostream>
#include <sstream>
#include "epparser.h"
#include "pygen.h"
#include "tokenAdapter.h"
#include "tokenizer/tokenizer.h"

static int tmpIndex = 0;
static bool errorOccured = false;
Token* genTemp(Token* lineSrc) {
    static char output[20] = "_t";
    sprintf(output, "_t%d", tmpIndex++);
    return new Token(output, lineSrc);
}

void throw_error(int line, int code, const std::string& message) {
    std::cout << "[Error " << code << "] Line " << line << " : " << message << std::endl;
    errorOccured = true;
}

}

%include {

// Loop block related
struct LBlock {
    std::string lbegin;
    std::string lcont;
    std::string lend;
};

std::vector<LBlock> lblocks;

LBlock* getLastBlock() {
    if(lblocks.empty()) return nullptr;
    return &lblocks[lblocks.size() - 1];
}

}

%syntax_error {
    errorOccured = true;
}

////////

%extra_argument { PyGenerator* pGen }
%token_type {Token*}
%destructor nt { delete $$; }

// Precedence table

%left COMMA.

%left ASSIGN.

%left LOR.
%left LAND.
%right LNOT.
%right DOUBLE_LNOT.  // Faster optimization for double lnot

%nonassoc EQ LE LT GE GT NE.

%left BITOR.
%left BITXOR.
%left BITAND.
%left LSHIFT RSHIFT.
%left PLUS MINUS.
%left DIVIDE MULTIPLY MOD.
%right UNARY.

%nonassoc IFX.
%nonassoc IFNOT.
%nonassoc ELSE.


program ::= stmt.

// Common expressions
nameList(A) ::= NAME(B) COMMA NAME(C). { A = new Token((B->data) + ", " + (C->data), C); delete B; delete C; }
nameList(A) ::= nameList(B) COMMA NAME(C). { A = new Token((B->data) + ", " + (C->data), C); delete B; delete C; }
exprList(A) ::= expr(B). { A = B; }
exprList(A) ::= exprList(B) COMMA expr(C). { A = new Token((B->data) + ", " + (C->data), C); delete B; delete C; }

// Related to expressions
expr(A) ::= NUMBER(B). { A = B; }
expr(A) ::= NAME(B). {
    if(pGen->undefined(B->data)) {
        throw_error(B->line, 103, ("Undeclared variable \'" + (B->data) + "\'"));
        pGen->namedef(B->data);
    }
    A = B;
}

// Binary operators
expr(A) ::= expr(B) PLUS        expr(C). { A = genTemp(C); (*pGen) << A->data << " = " << B->data << " + "  << C->data << std::endl; delete B; delete C; }
expr(A) ::= expr(B) MINUS       expr(C). { A = genTemp(C); (*pGen) << A->data << " = " << B->data << " - "  << C->data << std::endl; delete B; delete C; }
expr(A) ::= expr(B) MULTIPLY    expr(C). { A = genTemp(C); (*pGen) << A->data << " = " << B->data << " * "  << C->data << std::endl; delete B; delete C; }
expr(A) ::= expr(B) DIVIDE      expr(C). { A = genTemp(C); (*pGen) << A->data << " = " << B->data << " // " << C->data << std::endl; delete B; delete C; }
expr(A) ::= expr(B) MOD         expr(C). { A = genTemp(C); (*pGen) << A->data << " = " << B->data << " % "  << C->data << std::endl; delete B; delete C; }
expr(A) ::= expr(B) LSHIFT      expr(C). { A = genTemp(C); (*pGen) << A->data << " = " << B->data << " << " << C->data << std::endl; delete B; delete C; }
expr(A) ::= expr(B) RSHIFT      expr(C). { A = genTemp(C); (*pGen) << A->data << " = " << B->data << " >> " << C->data << std::endl; delete B; delete C; }
expr(A) ::= expr(B) BITAND      expr(C). { A = genTemp(C); (*pGen) << A->data << " = " << B->data << " & "  << C->data << std::endl; delete B; delete C; }
expr(A) ::= expr(B) BITOR       expr(C). { A = genTemp(C); (*pGen) << A->data << " = " << B->data << " | "  << C->data << std::endl; delete B; delete C; }
expr(A) ::= expr(B) BITXOR      expr(C). { A = genTemp(C); (*pGen) << A->data << " = " << B->data << " ^ "  << C->data << std::endl; delete B; delete C; }

// Unary operators
expr(A) ::= PLUS    expr(B). [UNARY] { A = genTemp(B); (*pGen) << A->data << " = +" << B->data << std::endl; delete B; }
expr(A) ::= MINUS   expr(B). [UNARY] { A = genTemp(B); (*pGen) << A->data << " = -" << B->data << std::endl; delete B; }
expr(A) ::= BITNOT  expr(B). [UNARY] { A = genTemp(B); (*pGen) << A->data << " = ~" << B->data << std::endl; delete B; }

// Logical operators
lexpr(A) ::= expr(B) EQ expr(C).   { A = genTemp(C); (*pGen) << A->data << " = (" << B->data << " == " << C->data << ")" << std::endl; delete B; delete C; }
lexpr(A) ::= expr(B) NE expr(C).   { A = genTemp(C); (*pGen) << A->data << " = (" << B->data << " != " << C->data << ")" << std::endl; delete B; delete C; }
lexpr(A) ::= expr(B) LE expr(C).   { A = genTemp(C); (*pGen) << A->data << " = (" << B->data << " <= " << C->data << ")" << std::endl; delete B; delete C; }
lexpr(A) ::= expr(B) LT expr(C).   { A = genTemp(C); (*pGen) << A->data << " = (" << B->data << " < "  << C->data << ")" << std::endl; delete B; delete C; }
lexpr(A) ::= expr(B) GE expr(C).   { A = genTemp(C); (*pGen) << A->data << " = (" << B->data << " >= " << C->data << ")" << std::endl; delete B; delete C; }
lexpr(A) ::= expr(B) GT expr(C).   { A = genTemp(C); (*pGen) << A->data << " = (" << B->data << " > "  << C->data << ")" << std::endl; delete B; delete C; }

lexpr(A) ::= lexpr(B) LAND lexpr(C).  { A = genTemp(C); (*pGen) << A->data << " = [" << B->data << ", " << C->data << "]" << std::endl; delete B; delete C; }
lexpr(A) ::= lexpr(B) LOR  lexpr(C).  { A = genTemp(C); (*pGen) << A->data << " = EUDOr([" << B->data << ", " << C->data << "])" << std::endl; delete B; delete C; }
lexpr(A) ::= LNOT lexpr(B). { A = genTemp(B); (*pGen) << A->data << " = EUDNot(" << B->data << ")" << std::endl; delete B; }
lexpr(A) ::= LNOT LNOT lexpr(B).  [DOUBLE_LNOT] { A = B; }

// Statements
vdef_stmt ::= VAR NAME(A) SEMICOLON. {
    (*pGen) << A->data << " = EUDVariable()" << std::endl;
    pGen->namedef(A->data);
    delete A;
}

vdefAssign_stmt ::= VAR NAME(A) ASSIGN expr(B) SEMICOLON. {
    (*pGen) << A->data << " = EUDVariable()" << std::endl;
    (*pGen) << A->data << " << " << B->data << std::endl;
    pGen->namedef(A->data);
    delete A;
}

vdefMulti_stmt ::= VAR nameList(A) SEMICOLON. {
    std::string& s = A->data;
    int varCount = std::count(s.begin(), s.end(), ',') + 1;
    (*pGen) << s << " = EUDCreateVariables(" << varCount << ")" << std::endl;

    // Register variables.
    const char *p = s.data(), *p2 = p;
    while(1) {
        while(*p2 != '\0' && *p2 != ',') p2++;
        pGen->namedef(std::string(p, p2 - p));
        if(*p2 == '\0') break;
        p = p2 = p2 + 2;
    }

    delete A;
}

vdefMultiAssign_stmt ::= VAR nameList(A) ASSIGN exprList(B) SEMICOLON. {
    std::string& s = A->data;
    int varCount = std::count(s.begin(), s.end(), ',') + 1;
    (*pGen) << s << " = EUDCreateVariables(" << varCount << ")" << std::endl;
    (*pGen) << "SetVariables([" << A->data << "], [" << B->data << "])" << std::endl;

    // Register variables.
    const char *p = s.data(), *p2 = p;
    while(1) {
        while(*p2 != '\0' && *p2 != ',') p2++;
        pGen->namedef(std::string(p, p2 - p));
        if(*p2 == '\0') break;
        p = p2 = p2 + 2;
    }

    delete A; delete B;
}

assign_stmt ::= NAME(A) ASSIGN expr(B) SEMICOLON. {
    (*pGen) << A->data << " << " << B->data << std::endl;
    if(pGen->undefined(A->data)) {
        throw_error(A->line, 103, ("Undeclared variable \'" + (A->data) + "\'"));
        pGen->namedef(A->data);
    }
    delete A; delete B;
}

assignMulti_stmt ::= nameList(A) ASSIGN exprList(B) SEMICOLON. {
    (*pGen) << "SetVariables([" << A->data << "], [" << B->data << "])" << std::endl;

    const char *p = A->data.data(), *p2 = p;
    while(1) {
        while(*p2 != '\0' && *p2 != ',') p2++;
        std::string varname(p, p2 - p);
        if(pGen->undefined(varname)) {
            throw_error(A->line, 103, ("Undeclared variable \'" + varname + "\'"));
            pGen->namedef(varname);
        }
        if(*p2 == '\0') break;
        p = p2 = p2 + 2;
    }

    delete A; delete B;
}

// Control blocks
stmtList ::= stmt.
stmtList ::= stmtList stmt.
block ::= LBRACKET stmtList RBRACKET.
block ::= LBRACKET error RBRACKET(A). {
    throw_error(A->line, 6974, "General syntax error");
}


// If~Else block
if_start(A) ::= IF(B). {
    A = genTemp(B);
    (*pGen) << A->data << " = Forward()" << std::endl;
}
if_header(C) ::= if_start(A) LPAREN lexpr(B) RPAREN. {
    (*pGen) << "EUDJumpIfNot(" << B->data << ", " << A->data << ")" << std::endl;
    C = A; delete B;
}

if_stmt ::= if_header(A) stmt. [IFX] {
    (*pGen) << A->data << " << NextTrigger()" << std::endl;
    delete A;
}

else_header(A) ::= if_header(B) stmt ELSE(C). [ELSE] {
    A = genTemp(C);
    (*pGen) << A->data << " = Forward()" << std::endl;
    (*pGen) << "EUDJump(" << A->data << ")" << std::endl;
    (*pGen) << B->data << " << NextTrigger()" << std::endl;
    delete B;
}

if_stmt ::= else_header(A) stmt. {
    (*pGen) << A->data << " << NextTrigger()" << std::endl;
    delete A;
}


// While block
while_start(A) ::= WHILE(B). {
    auto lbegin = genTemp(B);
    auto lend = genTemp(B);
    lblocks.push_back({lbegin->data, lbegin->data, lend->data});

    (*pGen) << lbegin->data << " = NextTrigger()" << std::endl;
    (*pGen) << lend->data << " = Forward()" << std::endl;
    A = lbegin;
    delete B;
}

while_cond ::= LPAREN lexpr(C) RPAREN(T). {
    auto lblock = getLastBlock();
    if(!lblock) {
        throw_error(T->line, 4217, "While scope is missing");
    }
    else {
        (*pGen) << "EUDJumpIfNot(" << C->data << ", " << lblock->lend << ")" << std::endl;
    }
    delete C; delete T;
}

while_stmt ::= while_start(T) while_cond stmt. {
    auto lblock = getLastBlock();
    if(!lblock) {
        throw_error(T->line, 4217, "While scope is missing");
    }
    else {
        (*pGen) << "EUDJump(" << lblock->lbegin << ")" << std::endl;
        (*pGen) << lblock->lend << " << NextTrigger()" << std::endl;
    }
    delete T;
}

// Loop exits
continue_stmt ::= CONTINUE SEMICOLON(T). {
    auto lblock = getLastBlock();
    if(!lblock) {
        throw_error(T->line, 1554, "Continue inside non-loop");
    }
    else {
        (*pGen) << "EUDJump(" << lblock->lcont << ")" << std::endl;
    }
    delete T;
}

break_stmt ::= BREAK SEMICOLON(T). {
    auto lblock = getLastBlock();
    if(!lblock) {
        throw_error(T->line, 5594, "Break inside non-loop");
    }
    else {
        (*pGen) << "EUDJump(" << lblock->lend << ")" << std::endl;
    }
    delete T;
}


// General statements
stmt ::= error SEMICOLON(A). { throw_error(A->line, 6974, "General syntax error"); }

stmt ::= SEMICOLON.
stmt ::= vdef_stmt.
stmt ::= vdefAssign_stmt.
stmt ::= vdefMultiAssign_stmt.
stmt ::= vdefMulti_stmt.
stmt ::= assign_stmt.
stmt ::= assignMulti_stmt.
stmt ::= expr SEMICOLON.
stmt ::= if_stmt.
stmt ::= while_stmt.
stmt ::= continue_stmt.
stmt ::= break_stmt.
stmt ::= block.


%code {

// #define PARSER_DEBUG

std::string ParseString(const std::string& code)
{
    std::istringstream is(code);
    Tokenizer tok(is);
    void* pParser = ParseAlloc (malloc);
    PyGenerator pGen;
    Token* token;

#ifdef PARSER_DEBUG
    std::cout << "Parsing string [[[\n" << code << "\n]]]\n";
#endif

    tmpIndex = 1;
    errorOccured = false;
    while((token = tok.getToken()) != nullptr) {
        if(tokenTypeConv(token)) {
            Parse (pParser, token->type, token, &pGen);
#ifdef PARSER_DEBUG
            ParseTrace(stdout, "-- ");
#endif
        }
        else {
            throw_error(token->line, 8104, "Invalid token");
        }
    }
    Parse (pParser, 0, nullptr, &pGen);
    ParseFree(pParser, free );

    if(!errorOccured) return pGen.str();
    else throw std::runtime_error("Invalid syntax");
}
}