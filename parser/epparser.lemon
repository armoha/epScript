%include {
#include <stdio.h>
#include <assert.h>
#include <string>
#include <iostream>
#include <sstream>
#include "epparser.h"
#include "pygen.h"
#include "tokenAdapter.h"
#include "tokenizer/tokenizer.h"

static int tmpIndex = 0;

std::string* genTemp() {
    static char output[20] = "_t";
    sprintf(output, "_t%d", tmpIndex++);
    return new std::string(output);
}

void throw_error(int code, const std::string& message) {
    std::cout << "[Error " << code << "] " << message << std::endl;
}

}

%syntax_error {
    printf("Syntax error!\n");
}

////////

%extra_argument { PyGenerator* pGen }
%token_type {std::string*}
%destructor nt { delete $$; }

// Precedence table

%left COMMA.

%left ASSIGN.

%left LOR.
%left LAND.
%right LNOT.
%right DOUBLE_LNOT.  // Faster optimization for double lnot

%nonassoc EQ LE LT GE GT NE.

%left BITOR.
%left BITXOR.
%left BITAND.
%left LSHIFT RSHIFT.
%left PLUS MINUS.
%left DIVIDE MULTIPLY MOD.
%right UNARY.

%nonassoc IFX.
%nonassoc IFNOT.
%nonassoc ELSE.


program ::= stmt.

// Common expressions
nameList(A) ::= NAME(B) COMMA NAME(C). { A = new std::string((*B) + ", " + (*C)); delete B; delete C; }
nameList(A) ::= nameList(B) COMMA NAME(C). { A = new std::string((*B) + ", " + (*C)); delete B; delete C; }
exprList(A) ::= expr(B). { A = B; }
exprList(A) ::= exprList(B) COMMA expr(C). { A = new std::string((*B) + ", " + (*C)); delete B; delete C; }

// Related to expressions
expr(A) ::= NUMBER(B). { A = B; }
expr(A) ::= NAME(B). {
    if(pGen->undefined(*B)) {
        throw_error(103, ("Undefined name \'" + (*B) + "\'"));
        pGen->namedef(*B);
    }
    A = B;
}

// Binary operators
expr(A) ::= expr(B) PLUS        expr(C). { A = genTemp(); (*pGen) << *A << " = " << *B << " + "  << *C << std::endl; delete B; delete C; }
expr(A) ::= expr(B) MINUS       expr(C). { A = genTemp(); (*pGen) << *A << " = " << *B << " - "  << *C << std::endl; delete B; delete C; }
expr(A) ::= expr(B) MULTIPLY    expr(C). { A = genTemp(); (*pGen) << *A << " = " << *B << " * "  << *C << std::endl; delete B; delete C; }
expr(A) ::= expr(B) DIVIDE      expr(C). { A = genTemp(); (*pGen) << *A << " = " << *B << " // " << *C << std::endl; delete B; delete C; }
expr(A) ::= expr(B) MOD         expr(C). { A = genTemp(); (*pGen) << *A << " = " << *B << " % "  << *C << std::endl; delete B; delete C; }
expr(A) ::= expr(B) LSHIFT      expr(C). { A = genTemp(); (*pGen) << *A << " = " << *B << " << " << *C << std::endl; delete B; delete C; }
expr(A) ::= expr(B) RSHIFT      expr(C). { A = genTemp(); (*pGen) << *A << " = " << *B << " >> " << *C << std::endl; delete B; delete C; }
expr(A) ::= expr(B) BITAND      expr(C). { A = genTemp(); (*pGen) << *A << " = " << *B << " & "  << *C << std::endl; delete B; delete C; }
expr(A) ::= expr(B) BITOR       expr(C). { A = genTemp(); (*pGen) << *A << " = " << *B << " | "  << *C << std::endl; delete B; delete C; }
expr(A) ::= expr(B) BITXOR      expr(C). { A = genTemp(); (*pGen) << *A << " = " << *B << " ^ "  << *C << std::endl; delete B; delete C; }

// Unary operators
expr(A) ::= PLUS    expr(B). [UNARY] { A = genTemp(); (*pGen) << *A << " = +" << *B << std::endl; delete B; }
expr(A) ::= MINUS   expr(B). [UNARY] { A = genTemp(); (*pGen) << *A << " = -" << *B << std::endl; delete B; }
expr(A) ::= BITNOT  expr(B). [UNARY] { A = genTemp(); (*pGen) << *A << " = ~" << *B << std::endl; delete B; }

// Logical operators
lexpr(A) ::= expr(B) EQ expr(C).   { A = genTemp(); (*pGen) << *A << " = (" << *B << " == " << *C << ")" << std::endl; delete B; delete C; }
lexpr(A) ::= expr(B) NE expr(C).   { A = genTemp(); (*pGen) << *A << " = (" << *B << " != " << *C << ")" << std::endl; delete B; delete C; }
lexpr(A) ::= expr(B) LE expr(C).   { A = genTemp(); (*pGen) << *A << " = (" << *B << " <= " << *C << ")" << std::endl; delete B; delete C; }
lexpr(A) ::= expr(B) LT expr(C).   { A = genTemp(); (*pGen) << *A << " = (" << *B << " < "  << *C << ")" << std::endl; delete B; delete C; }
lexpr(A) ::= expr(B) GE expr(C).   { A = genTemp(); (*pGen) << *A << " = (" << *B << " >= " << *C << ")" << std::endl; delete B; delete C; }
lexpr(A) ::= expr(B) GT expr(C).   { A = genTemp(); (*pGen) << *A << " = (" << *B << " > "  << *C << ")" << std::endl; delete B; delete C; }

lexpr(A) ::= lexpr(B) LAND lexpr(C).  { A = genTemp(); (*pGen) << *A << " = [" << *B << ", " << *C << "]" << std::endl; delete B; delete C; }
lexpr(A) ::= lexpr(B) LOR  lexpr(C).  { A = genTemp(); (*pGen) << *A << " = EUDOr([" << *B << ", " << *C << "])" << std::endl; delete B; delete C; }
lexpr(A) ::= LNOT lexpr(B). { A = genTemp(); (*pGen) << *A << " = EUDNot(" << *B << ")" << std::endl; delete B; }
lexpr(A) ::= LNOT LNOT lexpr(B).  [DOUBLE_LNOT] { A = B; }

// Statements
stmt_assignSingle ::= NAME(A) ASSIGN expr(B) SEMICOLON. {
    (*pGen) << *A << " << " << *B << std::endl;
    delete A; delete B;
}

stmt_assignMulti ::= nameList(A) ASSIGN exprList(B) SEMICOLON. {
    (*pGen) << "SetVariables([" << *A << "], [" << *B << "])" << std::endl;
    delete A; delete B;
}

// Control blocks

stmtList ::= stmt.
stmtList ::= stmtList stmt.
block ::= LBRACKET stmtList RBRACKET.
block ::= LBRACKET error RBRACKET.


// If~Else block
if_start(A) ::= IF. {
    A = genTemp();
    (*pGen) << *A << " = Forward()" << std::endl;
}
if_header(C) ::= if_start(A) LPAREN lexpr(B) RPAREN. {
    (*pGen) << "EUDJumpIfNot(" << *B << ", " << *A << ")" << std::endl;
    C = A; delete B;
}

if_stmt ::= if_header(A) stmt. [IFX] {
    (*pGen) << *A << " << NextTrigger()" << std::endl;
    delete A;
}

else_header(A) ::= if_header(B) stmt ELSE. [ELSE] {
    A = genTemp();
    (*pGen) << *A << " = Forward()" << std::endl;
    (*pGen) << "EUDJump(" << *A << ")" << std::endl;
    (*pGen) << *B << " << NextTrigger()" << std::endl;
    delete B;
}

if_stmt ::= else_header(A) stmt. {
    (*pGen) << *A << " << NextTrigger()" << std::endl;
    delete A;
}

stmt ::= error SEMICOLON.
stmt ::= expr SEMICOLON.
stmt ::= stmt_assignMulti.
stmt ::= stmt_assignSingle.
stmt ::= if_stmt.
stmt ::= block.


%code {
std::string ParseString(const std::string& code)
{
    std::istringstream is(code);
    Tokenizer tok(is);
    void* pParser = ParseAlloc (malloc);
    PyGenerator pGen;
    TokenPtr token;

    tmpIndex = 1;
    while((token = tok.getToken()) != nullptr) {
        int tokenType = tokenTypeConv(token->type);
        Parse (pParser, tokenType, new std::string(token->data), &pGen);
    }
    Parse (pParser, 0, nullptr, &pGen);
    ParseFree(pParser, free );
    return pGen.str();
}
}
