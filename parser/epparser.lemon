%include {
#include <stdio.h>
#include <assert.h>
#include <string>
#include <iostream>
#include <sstream>
#include "epparser.h"
#include "pygen.h"
#include "tokenAdapter.h"
#include "tokenizer/tokenizer.h"

static int tmpIndex = 0;

std::string* genTemp() {
    static char output[20] = "_t";
    sprintf(output, "_t%d", tmpIndex++);
    return new std::string(output);
}

void throw_error(int code, const std::string& message) {
    std::cout << "[Error " << code << "] " << message << std::endl;
}

}

%syntax_error {
    printf("Syntax error!\n");
}

////////

%extra_argument { PyGenerator* pGen }
%token_type {std::string*}
%destructor nt { delete $$; }

%left BITOR.
%left BITXOR.
%left BITAND.
%left LSHIFT RSHIFT.
%left PLUS MINUS.
%left DIVIDE MULTIPLY MOD.

program ::= stmt.

// Related to expressions
expr(A) ::= NUMBER(B). {
    A = B;
}

expr(A) ::= NAME(B). {
    if(pGen->undefined(*B)) {
        throw_error(103, ("Undefined name \'" + (*B) + "\'"));
        pGen->namedef(*B);
    }
    A = B;
}

// Binary operators
expr(A) ::= expr(B) PLUS        expr(C). { A = genTemp(); (*pGen) << *A << " = " << *B << " + "  << *C << std::endl; delete B; delete C; }
expr(A) ::= expr(B) MINUS       expr(C). { A = genTemp(); (*pGen) << *A << " = " << *B << " - "  << *C << std::endl; delete B; delete C; }
expr(A) ::= expr(B) MULTIPLY    expr(C). { A = genTemp(); (*pGen) << *A << " = " << *B << " * "  << *C << std::endl; delete B; delete C; }
expr(A) ::= expr(B) DIVIDE      expr(C). { A = genTemp(); (*pGen) << *A << " = " << *B << " // " << *C << std::endl; delete B; delete C; }
expr(A) ::= expr(B) MOD         expr(C). { A = genTemp(); (*pGen) << *A << " = " << *B << " % "  << *C << std::endl; delete B; delete C; }
expr(A) ::= expr(B) LSHIFT      expr(C). { A = genTemp(); (*pGen) << *A << " = " << *B << " << " << *C << std::endl; delete B; delete C; }
expr(A) ::= expr(B) RSHIFT      expr(C). { A = genTemp(); (*pGen) << *A << " = " << *B << " >> " << *C << std::endl; delete B; delete C; }
expr(A) ::= expr(B) BITAND      expr(C). { A = genTemp(); (*pGen) << *A << " = " << *B << " & "  << *C << std::endl; delete B; delete C; }
expr(A) ::= expr(B) BITOR       expr(C). { A = genTemp(); (*pGen) << *A << " = " << *B << " | "  << *C << std::endl; delete B; delete C; }
expr(A) ::= expr(B) BITXOR      expr(C). { A = genTemp(); (*pGen) << *A << " = " << *B << " ^ "  << *C << std::endl; delete B; delete C; }

// Statements
stmt_assignSingle ::= NAME(A) ASSIGN expr(B). {
    (*pGen) << *A << " << " << *B << std::endl;
    delete A; delete B;
}

nameList(A) ::= NAME(B) COMMA NAME(C). {
    A = new std::string((*B) + ", " + (*C));
    delete B; delete C;
}

nameList(A) ::= nameList(B) COMMA NAME(C). {
    A = new std::string((*B) + ", " + (*C));
    delete B; delete C;
}

exprList(A) ::= expr(B). {
    A = B;
}

exprList(A) ::= exprList(B) COMMA expr(C). {
    A = new std::string((*B) + ", " + (*C));
    delete B; delete C;
}

stmt_assignMulti ::= nameList(A) ASSIGN exprList(B). {
    (*pGen) << "SetVariables([" << *A << "], [" << *B << "])" << std::endl;
    delete A; delete B;
}

stmt ::= expr(A). { delete A; }
stmt ::= stmt_assignMulti.
stmt ::= stmt_assignSingle.


%code {
std::string ParseString(const std::string& code)
{
    std::istringstream is(code);
    Tokenizer tok(is);
    void* pParser = ParseAlloc (malloc);
    PyGenerator pGen;
    TokenPtr token;

    tmpIndex = 1;
    while((token = tok.getToken()) != nullptr) {
        int tokenType = tokenTypeConv(token->type);
        Parse (pParser, tokenType, new std::string(token->data), &pGen);
    }
    Parse (pParser, 0, nullptr, &pGen);
    ParseFree(pParser, free );
    return pGen.str();
}
}
