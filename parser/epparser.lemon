%include {
#include <stdio.h>
#include <assert.h>
#include <string>
#include <iostream>
#include <sstream>
#include "epparser.h"
#include "generator/pygen.h"
#include "generator/closure.h"
#include "tokenAdapter.h"
#include "parserUtilities.h"

struct ParserStruct {
    PyGenerator gen;
    ClosureManager closure;
};

int currentTokenizingLine;
}

%syntax_error {
    errorOccured = true;
}

////////

%extra_argument { ParserStruct* ps }
%token_type {Token*}
%destructor nt { delete $$; }

// Precedence table

%left COMMA.
%left ASSIGN.

%left LOR.
%left LAND.
%right LNOT.
%right DOUBLE_LNOT.  // Faster optimization for double lnot

%nonassoc EQ LE LT GE GT NE.

%left BITOR.
%left BITXOR.
%left BITAND.
%left LSHIFT RSHIFT.
%left PLUS MINUS.
%left DIVIDE MULTIPLY MOD.
%right UNARY BITNOT.
%nonassoc NUMBER NAME.

program ::= chunks.

// Common expressions
numList(A) ::= NUMBER(B) COMMA NUMBER(C). {
    A = new Token(B->data + ", " + C->data, C);
    delete B; delete C;
}
numList(A) ::= numList(B) COMMA NUMBER(C). {
    A = new Token(B->data + ", " + C->data, C);
    delete B; delete C;
}
nameListMulti(A) ::= NAME(B) COMMA NAME(C). { A = new Token((B->data) + ", " + (C->data), C); delete B; delete C; }
nameListMulti(A) ::= nameListMulti(B) COMMA NAME(C). { A = new Token((B->data) + ", " + (C->data), C); delete B; delete C; }
nameList(A) ::= NAME(B). { A = B; }
nameList(A) ::= nameListMulti(B). { A = B; }

exprList(A) ::= funcexpr(B) LSQBRACKET LSQBRACKET numList(C) RSQBRACKET RSQBRACKET. {
    A = genTemp(C);
    ps->gen << A->data << " = _SRET(" << B->data << ", [" << C->data << "])" << std::endl;
    delete B; delete C;
}

expr(A) ::= funcexpr(B) LSQBRACKET LSQBRACKET NUMBER(C) RSQBRACKET RSQBRACKET. {
    A = genTemp(C);
    ps->gen << A->data << " = _SRET(" << B->data << ", [" << C->data << "])" << std::endl;
    delete B; delete C;
}

exprList(A) ::= expr(B). [COMMA] { A = B; }
exprList(A) ::= exprList(B) COMMA exprList(C). { A = new Token((B->data) + ", " + (C->data), C); delete B; delete C; }

// Related to expressions
expr(A) ::= NUMBER(B). { A = B; }
expr(A) ::= NAME(B). {
    if(!ps->closure.getConstant(B->data) && !ps->closure.getVariable(B->data)) {
        throw_error(B->line, 103, ("Undeclared variable \'" + (B->data) + "\'"));
        ps->closure.defVariable(B->data);
    }
    A = B;
}

// Function calls
fArgs(A) ::= expr(B). { A = B; }
fArgs(A) ::= STRING(B). { A = B; }
fArgs(A) ::= fArgs(B) COMMA fArgs(C). {
    B->data = B->data + ", " + C->data;
    B->type = TOKEN_TEMP;
    A = B;
}

funcexpr(out) ::= NAME(name) LPAREN fArgs(exprs) RPAREN.  [FUNCCALL] {
    // Preprocess name
    funcNamePreprocess(name->data);
    if (!ps->closure.getFunction(name->data)) {
        throw_error(name->line, 4449, ("Undefined function " + name->data));
        ps->closure.defFunction(name->data);
    }

    name->data += "(" + exprs->data + ")";
    out = mkTokenTemp(name, ps->gen);
}


funcexpr(out) ::= NAME(name) LPAREN RPAREN.  [FUNCCALL] {
    // Preprocess name
    funcNamePreprocess(name->data);
    if (!ps->closure.getFunction(name->data)) {
        throw_error(name->line, 4449, ("Undefined function " + name->data));
        ps->closure.defFunction(name->data);
    }

    name->data += "()";
    out = mkTokenTemp(name, ps->gen);
}


// Binary operators
expr(A) ::= funcexpr(B).  { A = B; }
expr(A) ::= LPAREN expr(B) RPAREN. {
    B->data = "(" + B->data + ")";
    A = mkTokenTemp(B, ps->gen);
}

expr(A) ::= MAPSTRING LPAREN STRING(B) RPAREN. {
    B->data = "GetStringIndex(" + B->data + ")";
    A = mkTokenTemp(B, ps->gen);
}

expr(A) ::= UNIT LPAREN STRING(B) RPAREN. {
    B->data = "GetUnitIndex(" + B->data + ")";
    A = mkTokenTemp(B, ps->gen);
}

expr(A) ::= SWITCH LPAREN STRING(B) RPAREN. {
    B->data = "GetSwitchIndex(" + B->data + ")";
    A = mkTokenTemp(B, ps->gen);
}

expr(A) ::= LOCATION LPAREN STRING(B) RPAREN. {
    B->data = "GetLocationIndex(" + B->data + ")";
    A = mkTokenTemp(B, ps->gen);
}

expr(A) ::= expr(B) PLUS        expr(C). { A = binaryMerge(B, "+",  C, ps->gen); }
expr(A) ::= expr(B) MINUS       expr(C). { A = binaryMerge(B, "-",  C, ps->gen); }
expr(A) ::= expr(B) MULTIPLY    expr(C). { A = binaryMerge(B, "*",  C, ps->gen); }
expr(A) ::= expr(B) DIVIDE      expr(C). { A = binaryMerge(B, "//", C, ps->gen); }
expr(A) ::= expr(B) MOD         expr(C). { A = binaryMerge(B, "%",  C, ps->gen); }
expr(A) ::= expr(B) LSHIFT      expr(C). { A = binaryMerge(B, "<<", C, ps->gen); }
expr(A) ::= expr(B) RSHIFT      expr(C). { A = binaryMerge(B, ">>", C, ps->gen); }
expr(A) ::= expr(B) BITAND      expr(C). { A = binaryMerge(B, "&",  C, ps->gen); }
expr(A) ::= expr(B) BITOR       expr(C). { A = binaryMerge(B, "|",  C, ps->gen); }
expr(A) ::= expr(B) BITXOR      expr(C). { A = binaryMerge(B, "^",  C, ps->gen); }

// Unary operators
expr(A) ::= PLUS    expr(B). [UNARY] { A = genTemp(B); ps->gen << A->data << " = +" << B->data << std::endl; delete B; }
expr(A) ::= MINUS   expr(B). [UNARY] { A = genTemp(B); ps->gen << A->data << " = -" << B->data << std::endl; delete B; }
expr(A) ::= BITNOT  expr(B). [UNARY] { A = genTemp(B); ps->gen << A->data << " = ~" << B->data << std::endl; delete B; }


lexpr(A) ::= expr(B) EQ expr(C).   { A = binaryMerge(B, "==", C, ps->gen); }
lexpr(A) ::= expr(B) NE expr(C).   { A = binaryMerge(B, "!=", C, ps->gen); }
lexpr(A) ::= expr(B) LE expr(C).   { A = binaryMerge(B, "<=", C, ps->gen); }
lexpr(A) ::= expr(B) LT expr(C).   { A = binaryMerge(B, "<",  C, ps->gen); }
lexpr(A) ::= expr(B) GE expr(C).   { A = binaryMerge(B, ">=", C, ps->gen); }
lexpr(A) ::= expr(B) GT expr(C).   { A = binaryMerge(B, ">" , C, ps->gen); }

lexpr(A) ::= lexpr(B) LAND lexpr(C).  {
    B->data = "[" + B->data + ", " + C->data + "]";
    delete C;
    A = mkTokenTemp(B, ps->gen);
}

lexpr(A) ::= lexpr(B) LOR lexpr(C).  {
    B->data = "EUDOr([" + B->data + ", " + C->data + "])";
    delete C;
    A = mkTokenTemp(B, ps->gen);
}

lexpr(A) ::= LNOT lexpr(B).  {
    B->data = "EUDNot([" + B->data + "])";
    A = mkTokenTemp(B, ps->gen);
}

lexpr(A) ::= LNOT LNOT lexpr(B).  [DOUBLE_LNOT] { A = B; }



// Statements
vdef_stmt ::= VAR nameList(A) SEMICOLON. {
    std::string& s = A->data;
    int varCount = std::count(s.begin(), s.end(), ',') + 1;

    // Register variables.
    commaListIter(s, [&](std::string& varname) {
        if(!ps->closure.defVariable(varname)) {
            throw_error(A->line, 196, ("Redeclaration of variable \'" + varname + "\'"));
        }
    });
    ps->gen << s << " = EUDCreateVariables(" << varCount << ")" << std::endl;
    delete A;
}

vdefAssign_stmt ::= VAR nameList(A) ASSIGN exprList(B) SEMICOLON. {
    std::string& s = A->data;

    // Register variables.
    commaListIter(s, [&](std::string& varname) {
        if(!ps->closure.defVariable(varname)) {
            throw_error(A->line, 196, ("Redeclaration of variable \'" + varname + "\'"));
        }
    });
    ps->gen << s << " = _MVAR([" << B->data << "])" << std::endl;
    delete A; delete B;
}

cdef_stmt ::= CONST nameList(A) ASSIGN exprList(B) SEMICOLON. {
    std::string& s = A->data;

    // Register constants.
    commaListIter(s, [&](std::string& constname) {
        if(!ps->closure.defConstant(constname)) {
            throw_error(A->line, 196, ("Redeclaration of constant \'" + constname + "\'"));
        }
    });
    ps->gen << s << " = List2Assignable([" << B->data << "])" << std::endl;
    delete A; delete B;
}

assign_stmt ::= NAME(A) ASSIGN expr(B) SEMICOLON. {
    ps->gen << A->data << " << " << B->data << std::endl;
    if(!ps->closure.getVariable(A->data)) {
        throw_error(A->line, 103, ("Undeclared variable \'" + (A->data) + "\'"));
        ps->closure.defVariable(A->data);
    }
    delete A; delete B;
}

assignMulti_stmt ::= nameListMulti(A) ASSIGN exprList(B) SEMICOLON. {
    ps->gen << "SetVariables([" << A->data << "], [" << B->data << "])" << std::endl;

    commaListIter(A->data, [&](std::string& varname) {
        if(!ps->closure.defVariable(varname)) {
            throw_error(A->line, 103, ("Undeclared variable \'" + varname + "\'"));
            ps->closure.defVariable(varname);
        }
    });

    delete A; delete B;
}

// Control blocks
stmtList ::= stmt.
stmtList ::= stmtList stmt.
blockStart ::= LBRACKET. {
    ps->closure.pushScope();
}

block ::= blockStart stmtList RBRACKET. {
    ps->closure.popScope();
}

block ::= blockStart error RBRACKET(A). {
    throw_error(A->line, 6298, "Block not terminated properly.");
    ps->closure.popScope();
}


// If~Else block
if_start(A) ::= IF(B). {
    A = genTemp(B);
    ps->gen << A->data << " = EUDIf()" << std::endl;
}
if_header ::= if_start(A) LPAREN lexpr(B) RPAREN. {
    ps->gen << "if " << A->data << "(" << B->data << "):" << std::endl;
    ps->gen.indent();
    delete A; delete B;
}

if_block ::= if_header stmt.

elif_start(A) ::= ELSE IF(B). {
    A = genTemp(B);
    ps->gen.unindent(false);
    ps->gen << A->data << " = EUDElseIf()" << std::endl;
}

elif_header ::= elif_start(A) LPAREN lexpr(B) RPAREN. {
    ps->gen << "if " << A->data << "(" << B->data <<"):" << std::endl;
    ps->gen.indent();
}

if_block ::= if_block elif_header stmt.

else_header ::= ELSE. {
    ps->gen.unindent(false);
    ps->gen << "if EUDElse()():" << std::endl;
    ps->gen.indent();
}

if_stmt ::= if_block. {
    ps->gen.unindent(false);
    ps->gen << "EUDEndIf()" << std::endl;
}

if_stmt ::= if_block else_header stmt. {
    ps->gen.unindent(false);
    ps->gen << "EUDEndIf()" << std::endl;
}


// While block
while_start(A) ::= WHILE(B). {
    A = genTemp(B);
    ps->gen << A->data << " = EUDWhile()" << std::endl;
    delete B;
}

while_header ::= while_start(A) LPAREN lexpr(B) RPAREN. {
    ps->gen << "if " << A->data << "(" << B->data << "):" << std::endl;
    ps->gen.indent();
    delete A; delete B;
}

while_stmt ::= while_header stmt. {
    ps->gen.unindent(false);
    ps->gen << "EUDEndWhile()" << std::endl;
}

// Foreach block
foreach_header ::= FOR LPAREN nameList(names) COLON exprList(exprs) RPAREN. {
    ps->gen << "for " << names->data << " in " << exprs->data << ":" << std::endl;
    ps->gen.indent();
    commaListIter(names->data, [&](std::string& s) {
        ps->closure.defVariable(s);
    });
}

foreach_stmt ::= foreach_header stmt. {
    ps->gen.unindent(true);
}


// Loop exits
continue_stmt ::= CONTINUE SEMICOLON. {
    ps->gen << "EUDContinue()" << std::endl;
}

break_stmt ::= BREAK SEMICOLON. {
    ps->gen << "EUDBreak()" << std::endl;
}

// Function declaration
function_start(start) ::= FUNCTION NAME(name).  {
    // Preprocess name
    funcNamePreprocess(name->data);
    start = name;
    if(!ps->closure.defFunction(name->data)) {
        throw_error(name->line, 4495, "Duplicate function name " + name->data);
    }
}

function_header ::= function_start(fname) LPAREN nameList(args) RPAREN. {
    ps->gen << "@EUDFunc" << std::endl;
    ps->gen << "def " << fname->data << "(" << args->data << "):" << std::endl;
    ps->gen.indent();

    // Register variables.
    const std::string& s = args->data;
    commaListIter(args->data, [&](std::string& varname) {
        if(!ps->closure.defVariable(varname)) {
            throw_error(args->line, 196, ("Redeclaration of variable \'" + varname + "\'"));
        }
    });

    tmpIndex = 1;
    delete fname; delete args;
}

function_header ::= function_start(fname) LPAREN RPAREN. {
    ps->gen << "@EUDFunc" << std::endl;
    ps->gen << "def " << fname->data << "():" << std::endl;
    ps->gen.indent();
    tmpIndex = 1;
    delete fname;
}

fdef_chunk ::= function_header stmt. {
    ps->gen.unindent(true);
}


// returns
return_stmt ::= RETURN SEMICOLON. {
    ps->gen << "EUDReturn()" << std::endl;
}

return_stmt ::= RETURN exprList(exprs) SEMICOLON. {
    ps->gen << "EUDReturn(" << exprs->data << ")" << std::endl;
    delete exprs;
}


// Trigger statements

lexpr(A) ::= CONDITIONNAME(B) LPAREN fArgs(C) RPAREN. {
    B->data = B->data + "(" + C->data + ")";
    delete C;
    A = mkTokenTemp(B, ps->gen);
}

lexpr(A) ::= CONDITIONNAME(B) LPAREN RPAREN. {
    B->data = B->data + "()";
    A = mkTokenTemp(B, ps->gen);
}

action(X) ::= ACTIONNAME(A) LPAREN fArgs(B) RPAREN SEMICOLON. {
    X = genTemp(A);
    X->data =  A->data + "(" + B->data + ")";
    delete A; delete B;
}

actions(A) ::= action(B) action(C). {
    A = B;
    B->data += ",\n" + C->data;
    delete C;
}

actions(A) ::= actions(B) action(C). {
    A = B;
    B->data += ",\n" + C->data;
    delete C;
}

actionStmt ::= action(X). {
    ps->gen << "DoActions(" << X->data << ")" << std::endl;
    delete X;
}

actionStmt ::= actions(X). {
    ps->gen << "DoActions([" << std::endl;
    ps->gen.indent();
    ps->gen << X->data << std::endl;
    ps->gen.unindent(false);
    ps->gen << "])" << std::endl;
    delete X;
}


// General statements
stmt ::= error SEMICOLON(A). { throw_error(A->line, 6974, "Error while parsing statement"); }


stmt ::= SEMICOLON.
stmt ::= vdef_stmt.
stmt ::= vdefAssign_stmt.
stmt ::= cdef_stmt.
stmt ::= assign_stmt.
stmt ::= assignMulti_stmt.
stmt ::= funcexpr(A) SEMICOLON. { ps->gen << A->data << std::endl; }
stmt ::= actionStmt.
stmt ::= if_stmt.
stmt ::= while_stmt.
stmt ::= foreach_stmt.
stmt ::= continue_stmt.
stmt ::= break_stmt.
stmt ::= return_stmt.
stmt ::= block.


// Program building block

import_chunk ::= FROM NAME(name) IMPORT nameList(B). {
    ps->gen << "from " << name->data << " import " << B->data << std::endl;
    commaListIter(B->data, [&](std::string varname) {
        funcNamePreprocess(varname);
        if(!ps->closure.defFunction(varname)) {
            throw_error(B->line, 8118, ("Importing already-declared function " + varname));
        }
        else ps->gen << "from " << name->data << " import " << varname << std::endl;
    });
    delete name; delete B;
}

chunk ::= import_chunk.
chunk ::= fdef_chunk.
chunk ::= vdef_stmt.
chunk ::= cdef_stmt.
chunks ::= .
chunks ::= chunks chunk.

%code {

int PARSER_DEBUG = 0;

std::string ParseString(const std::string& code)
{
    Tokenizer tok(code);
    void* pParser = ParseAlloc (malloc);
    ParserStruct ps;
    Token* token;
    currentTokenizingLine = 0;

    if(PARSER_DEBUG) std::cout << "Parsing string [[[\n" << code.c_str() << "\n]]]\n";

    tmpIndex = 1;
    errorOccured = false;
    while ((token = tok.getToken()) != nullptr) {
        if (currentTokenizingLine != tok.getCurrentLine()) {
            currentTokenizingLine = tok.getCurrentLine();
            ps.gen << "# (Line " << currentTokenizingLine << ") " << trim(tok.getCurrentLineString()) << std::endl;
            if(PARSER_DEBUG) printf("# reading line %s\n", tok.getCurrentLineString().c_str());
        }
        if (tokenTypeConv(token)) {
            Parse (pParser, token->type, token, &ps);
#ifndef NDEBUG
            if(PARSER_DEBUG) ParseTrace(stdout, "--");
#endif
        }
        else {
            throw_error(token->line, 8104, "Invalid token");
        }
    }
    Parse (pParser, 0, nullptr, &ps);
    ParseFree(pParser, free );

    if(!errorOccured) return postProcessCode(ps.gen.str());
    else throw std::runtime_error("Invalid syntax");
}
}